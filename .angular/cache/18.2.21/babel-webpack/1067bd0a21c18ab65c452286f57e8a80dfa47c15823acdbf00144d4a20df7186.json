{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { untracked, isSignal, computed, assertInInjectionContext, inject, Injector, DestroyRef, signal, Injectable } from '@angular/core';\nfunction toDeepSignal(signal) {\n  const value = untracked(() => signal());\n  if (!isRecord(value)) {\n    return signal;\n  }\n  return new Proxy(signal, {\n    get(target, prop) {\n      if (!(prop in value)) {\n        return target[prop];\n      }\n      if (!isSignal(target[prop])) {\n        Object.defineProperty(target, prop, {\n          value: computed(() => target()[prop]),\n          configurable: true\n        });\n      }\n      return toDeepSignal(target[prop]);\n    }\n  });\n}\nfunction isRecord(value) {\n  return value?.constructor === Object;\n}\nfunction deepComputed(computation) {\n  return toDeepSignal(computed(computation));\n}\nconst STATE_WATCHERS = new WeakMap();\nconst STATE_SOURCE = Symbol('STATE_SOURCE');\nfunction patchState(stateSource, ...updaters) {\n  stateSource[STATE_SOURCE].update(currentState => updaters.reduce((nextState, updater) => ({\n    ...nextState,\n    ...(typeof updater === 'function' ? updater(nextState) : updater)\n  }), currentState));\n  notifyWatchers(stateSource);\n}\nfunction getState(stateSource) {\n  return stateSource[STATE_SOURCE]();\n}\nfunction watchState(stateSource, watcher, config) {\n  if (!config?.injector) {\n    assertInInjectionContext(watchState);\n  }\n  const injector = config?.injector ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  addWatcher(stateSource, watcher);\n  watcher(getState(stateSource));\n  const destroy = () => removeWatcher(stateSource, watcher);\n  destroyRef.onDestroy(destroy);\n  return {\n    destroy\n  };\n}\nfunction getWatchers(stateSource) {\n  return STATE_WATCHERS.get(stateSource[STATE_SOURCE]) || [];\n}\nfunction notifyWatchers(stateSource) {\n  const watchers = getWatchers(stateSource);\n  for (const watcher of watchers) {\n    const state = untracked(() => getState(stateSource));\n    watcher(state);\n  }\n}\nfunction addWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], [...watchers, watcher]);\n}\nfunction removeWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], watchers.filter(w => w !== watcher));\n}\nfunction signalState(initialState) {\n  const stateSource = signal(initialState);\n  const signalState = toDeepSignal(stateSource.asReadonly());\n  Object.defineProperty(signalState, STATE_SOURCE, {\n    value: stateSource\n  });\n  return signalState;\n}\nfunction signalStore(...args) {\n  const signalStoreArgs = [...args];\n  const config = typeof signalStoreArgs[0] === 'function' ? {} : signalStoreArgs.shift();\n  const features = signalStoreArgs;\n  class SignalStore {\n    constructor() {\n      const innerStore = features.reduce((store, feature) => feature(store), getInitialInnerStore());\n      const {\n        stateSignals,\n        computedSignals,\n        methods,\n        hooks\n      } = innerStore;\n      const storeMembers = {\n        ...stateSignals,\n        ...computedSignals,\n        ...methods\n      };\n      this[STATE_SOURCE] = innerStore[STATE_SOURCE];\n      for (const key in storeMembers) {\n        this[key] = storeMembers[key];\n      }\n      const {\n        onInit,\n        onDestroy\n      } = hooks;\n      if (onInit) {\n        onInit();\n      }\n      if (onDestroy) {\n        inject(DestroyRef).onDestroy(onDestroy);\n      }\n    }\n    /** @nocollapse */\n    static ɵfac = function SignalStore_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SignalStore)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SignalStore,\n      factory: SignalStore.ɵfac,\n      providedIn: config.providedIn || null\n    });\n  }\n  (() => {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SignalStore, [{\n      type: Injectable,\n      args: [{\n        providedIn: config.providedIn || null\n      }]\n    }], () => [], null);\n  })();\n  return SignalStore;\n}\nfunction getInitialInnerStore() {\n  return {\n    [STATE_SOURCE]: signal({}),\n    stateSignals: {},\n    computedSignals: {},\n    methods: {},\n    hooks: {}\n  };\n}\nfunction signalStoreFeature(featureOrInput, ...restFeatures) {\n  const features = typeof featureOrInput === 'function' ? [featureOrInput, ...restFeatures] : restFeatures;\n  return inputStore => features.reduce((store, feature) => feature(store), inputStore);\n}\nfunction type() {\n  return undefined;\n}\nfunction assertUniqueStoreMembers(store, newMemberKeys) {\n  if (!ngDevMode) {\n    return;\n  }\n  const storeMembers = {\n    ...store.stateSignals,\n    ...store.computedSignals,\n    ...store.methods\n  };\n  const overriddenKeys = Object.keys(storeMembers).filter(memberKey => newMemberKeys.includes(memberKey));\n  if (overriddenKeys.length > 0) {\n    console.warn('@ngrx/signals: SignalStore members cannot be overridden.', 'Trying to override:', overriddenKeys.join(', '));\n  }\n}\nfunction withComputed(signalsFactory) {\n  return store => {\n    const computedSignals = signalsFactory({\n      ...store.stateSignals,\n      ...store.computedSignals\n    });\n    assertUniqueStoreMembers(store, Object.keys(computedSignals));\n    return {\n      ...store,\n      computedSignals: {\n        ...store.computedSignals,\n        ...computedSignals\n      }\n    };\n  };\n}\nfunction withHooks(hooksOrFactory) {\n  return store => {\n    const storeMembers = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.computedSignals,\n      ...store.methods\n    };\n    const hooks = typeof hooksOrFactory === 'function' ? hooksOrFactory(storeMembers) : hooksOrFactory;\n    const createHook = name => {\n      const hook = hooks[name];\n      const currentHook = store.hooks[name];\n      return hook ? () => {\n        if (currentHook) {\n          currentHook();\n        }\n        hook(storeMembers);\n      } : currentHook;\n    };\n    return {\n      ...store,\n      hooks: {\n        onInit: createHook('onInit'),\n        onDestroy: createHook('onDestroy')\n      }\n    };\n  };\n}\nfunction withMethods(methodsFactory) {\n  return store => {\n    const methods = methodsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.computedSignals,\n      ...store.methods\n    });\n    assertUniqueStoreMembers(store, Object.keys(methods));\n    return {\n      ...store,\n      methods: {\n        ...store.methods,\n        ...methods\n      }\n    };\n  };\n}\nfunction withState(stateOrFactory) {\n  return store => {\n    const state = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n    const stateKeys = Object.keys(state);\n    assertUniqueStoreMembers(store, stateKeys);\n    store[STATE_SOURCE].update(currentState => ({\n      ...currentState,\n      ...state\n    }));\n    const stateSignals = stateKeys.reduce((acc, key) => {\n      const sliceSignal = computed(() => store[STATE_SOURCE]()[key]);\n      return {\n        ...acc,\n        [key]: toDeepSignal(sliceSignal)\n      };\n    }, {});\n    return {\n      ...store,\n      stateSignals: {\n        ...store.stateSignals,\n        ...stateSignals\n      }\n    };\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { deepComputed, getState, patchState, signalState, signalStore, signalStoreFeature, type, watchState, withComputed, withHooks, withMethods, withState };","map":{"version":3,"names":["i0","untracked","isSignal","computed","assertInInjectionContext","inject","Injector","DestroyRef","signal","Injectable","toDeepSignal","value","isRecord","Proxy","get","target","prop","Object","defineProperty","configurable","constructor","deepComputed","computation","STATE_WATCHERS","WeakMap","STATE_SOURCE","Symbol","patchState","stateSource","updaters","update","currentState","reduce","nextState","updater","notifyWatchers","getState","watchState","watcher","config","injector","destroyRef","addWatcher","destroy","removeWatcher","onDestroy","getWatchers","watchers","state","set","filter","w","signalState","initialState","asReadonly","signalStore","args","signalStoreArgs","shift","features","SignalStore","innerStore","store","feature","getInitialInnerStore","stateSignals","computedSignals","methods","hooks","storeMembers","key","onInit","ɵfac","SignalStore_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","signalStoreFeature","featureOrInput","restFeatures","inputStore","undefined","assertUniqueStoreMembers","newMemberKeys","overriddenKeys","keys","memberKey","includes","length","console","warn","join","withComputed","signalsFactory","withHooks","hooksOrFactory","createHook","name","hook","currentHook","withMethods","methodsFactory","withState","stateOrFactory","stateKeys","acc","sliceSignal"],"sources":["/Users/sagishutrit/Desktop/datepicker/mapbox-angular/node_modules/@ngrx/signals/fesm2022/ngrx-signals.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { untracked, isSignal, computed, assertInInjectionContext, inject, Injector, DestroyRef, signal, Injectable } from '@angular/core';\n\nfunction toDeepSignal(signal) {\n    const value = untracked(() => signal());\n    if (!isRecord(value)) {\n        return signal;\n    }\n    return new Proxy(signal, {\n        get(target, prop) {\n            if (!(prop in value)) {\n                return target[prop];\n            }\n            if (!isSignal(target[prop])) {\n                Object.defineProperty(target, prop, {\n                    value: computed(() => target()[prop]),\n                    configurable: true,\n                });\n            }\n            return toDeepSignal(target[prop]);\n        },\n    });\n}\nfunction isRecord(value) {\n    return value?.constructor === Object;\n}\n\nfunction deepComputed(computation) {\n    return toDeepSignal(computed(computation));\n}\n\nconst STATE_WATCHERS = new WeakMap();\nconst STATE_SOURCE = Symbol('STATE_SOURCE');\nfunction patchState(stateSource, ...updaters) {\n    stateSource[STATE_SOURCE].update((currentState) => updaters.reduce((nextState, updater) => ({\n        ...nextState,\n        ...(typeof updater === 'function' ? updater(nextState) : updater),\n    }), currentState));\n    notifyWatchers(stateSource);\n}\nfunction getState(stateSource) {\n    return stateSource[STATE_SOURCE]();\n}\nfunction watchState(stateSource, watcher, config) {\n    if (!config?.injector) {\n        assertInInjectionContext(watchState);\n    }\n    const injector = config?.injector ?? inject(Injector);\n    const destroyRef = injector.get(DestroyRef);\n    addWatcher(stateSource, watcher);\n    watcher(getState(stateSource));\n    const destroy = () => removeWatcher(stateSource, watcher);\n    destroyRef.onDestroy(destroy);\n    return { destroy };\n}\nfunction getWatchers(stateSource) {\n    return STATE_WATCHERS.get(stateSource[STATE_SOURCE]) || [];\n}\nfunction notifyWatchers(stateSource) {\n    const watchers = getWatchers(stateSource);\n    for (const watcher of watchers) {\n        const state = untracked(() => getState(stateSource));\n        watcher(state);\n    }\n}\nfunction addWatcher(stateSource, watcher) {\n    const watchers = getWatchers(stateSource);\n    STATE_WATCHERS.set(stateSource[STATE_SOURCE], [...watchers, watcher]);\n}\nfunction removeWatcher(stateSource, watcher) {\n    const watchers = getWatchers(stateSource);\n    STATE_WATCHERS.set(stateSource[STATE_SOURCE], watchers.filter((w) => w !== watcher));\n}\n\nfunction signalState(initialState) {\n    const stateSource = signal(initialState);\n    const signalState = toDeepSignal(stateSource.asReadonly());\n    Object.defineProperty(signalState, STATE_SOURCE, {\n        value: stateSource,\n    });\n    return signalState;\n}\n\nfunction signalStore(...args) {\n    const signalStoreArgs = [...args];\n    const config = typeof signalStoreArgs[0] === 'function'\n        ? {}\n        : signalStoreArgs.shift();\n    const features = signalStoreArgs;\n    class SignalStore {\n        constructor() {\n            const innerStore = features.reduce((store, feature) => feature(store), getInitialInnerStore());\n            const { stateSignals, computedSignals, methods, hooks } = innerStore;\n            const storeMembers = { ...stateSignals, ...computedSignals, ...methods };\n            this[STATE_SOURCE] = innerStore[STATE_SOURCE];\n            for (const key in storeMembers) {\n                this[key] = storeMembers[key];\n            }\n            const { onInit, onDestroy } = hooks;\n            if (onInit) {\n                onInit();\n            }\n            if (onDestroy) {\n                inject(DestroyRef).onDestroy(onDestroy);\n            }\n        }\n        /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: SignalStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n        /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: SignalStore, providedIn: config.providedIn || null });\n    }\n    i0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: SignalStore, decorators: [{\n                type: Injectable,\n                args: [{ providedIn: config.providedIn || null }]\n            }], ctorParameters: () => [] });\n    return SignalStore;\n}\nfunction getInitialInnerStore() {\n    return {\n        [STATE_SOURCE]: signal({}),\n        stateSignals: {},\n        computedSignals: {},\n        methods: {},\n        hooks: {},\n    };\n}\n\nfunction signalStoreFeature(featureOrInput, ...restFeatures) {\n    const features = typeof featureOrInput === 'function'\n        ? [featureOrInput, ...restFeatures]\n        : restFeatures;\n    return (inputStore) => features.reduce((store, feature) => feature(store), inputStore);\n}\nfunction type() {\n    return undefined;\n}\n\nfunction assertUniqueStoreMembers(store, newMemberKeys) {\n    if (!ngDevMode) {\n        return;\n    }\n    const storeMembers = {\n        ...store.stateSignals,\n        ...store.computedSignals,\n        ...store.methods,\n    };\n    const overriddenKeys = Object.keys(storeMembers).filter((memberKey) => newMemberKeys.includes(memberKey));\n    if (overriddenKeys.length > 0) {\n        console.warn('@ngrx/signals: SignalStore members cannot be overridden.', 'Trying to override:', overriddenKeys.join(', '));\n    }\n}\n\nfunction withComputed(signalsFactory) {\n    return (store) => {\n        const computedSignals = signalsFactory({\n            ...store.stateSignals,\n            ...store.computedSignals,\n        });\n        assertUniqueStoreMembers(store, Object.keys(computedSignals));\n        return {\n            ...store,\n            computedSignals: { ...store.computedSignals, ...computedSignals },\n        };\n    };\n}\n\nfunction withHooks(hooksOrFactory) {\n    return (store) => {\n        const storeMembers = {\n            [STATE_SOURCE]: store[STATE_SOURCE],\n            ...store.stateSignals,\n            ...store.computedSignals,\n            ...store.methods,\n        };\n        const hooks = typeof hooksOrFactory === 'function'\n            ? hooksOrFactory(storeMembers)\n            : hooksOrFactory;\n        const createHook = (name) => {\n            const hook = hooks[name];\n            const currentHook = store.hooks[name];\n            return hook\n                ? () => {\n                    if (currentHook) {\n                        currentHook();\n                    }\n                    hook(storeMembers);\n                }\n                : currentHook;\n        };\n        return {\n            ...store,\n            hooks: {\n                onInit: createHook('onInit'),\n                onDestroy: createHook('onDestroy'),\n            },\n        };\n    };\n}\n\nfunction withMethods(methodsFactory) {\n    return (store) => {\n        const methods = methodsFactory({\n            [STATE_SOURCE]: store[STATE_SOURCE],\n            ...store.stateSignals,\n            ...store.computedSignals,\n            ...store.methods,\n        });\n        assertUniqueStoreMembers(store, Object.keys(methods));\n        return {\n            ...store,\n            methods: { ...store.methods, ...methods },\n        };\n    };\n}\n\nfunction withState(stateOrFactory) {\n    return (store) => {\n        const state = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n        const stateKeys = Object.keys(state);\n        assertUniqueStoreMembers(store, stateKeys);\n        store[STATE_SOURCE].update((currentState) => ({\n            ...currentState,\n            ...state,\n        }));\n        const stateSignals = stateKeys.reduce((acc, key) => {\n            const sliceSignal = computed(() => store[STATE_SOURCE]()[key]);\n            return { ...acc, [key]: toDeepSignal(sliceSignal) };\n        }, {});\n        return {\n            ...store,\n            stateSignals: { ...store.stateSignals, ...stateSignals },\n        };\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { deepComputed, getState, patchState, signalState, signalStore, signalStoreFeature, type, watchState, withComputed, withHooks, withMethods, withState };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}